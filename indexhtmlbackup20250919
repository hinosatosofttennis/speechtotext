<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI音声文字起こし (通知機能付き)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&family=Roboto+Mono:wght@400;500&family=Kaisei+Tokumin:wght@400;700&display=swap" rel="stylesheet">
    <!-- docx.js library for Word document generation -->
    <script src="https://unpkg.com/docx@7.3.0/build/index.js"></script>
    <style>
        /* Base styles */
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        /* Font classes for the editor */
        .font-inter { font-family: 'Inter', sans-serif; }
        .font-noto { font-family: 'Noto Sans JP', sans-serif; }
        .font-mono { font-family: 'Roboto Mono', monospace; }
        .font-mincho { font-family: 'Kaisei Tokumin', serif; }

        /* Custom loader animation */
        .loader {
            border: 4px solid #e5e7eb; /* gray-200 */
            border-top: 4px solid #3b82f6; /* blue-500 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        html.dark .loader {
            border-color: #4b5563; /* dark:gray-600 */
            border-top-color: #60a5fa; /* dark:blue-400 */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        html.dark ::-webkit-scrollbar-track { background: #2d3748; }
        ::-webkit-scrollbar-thumb { background: #a8a8a8; border-radius: 4px; }
        html.dark ::-webkit-scrollbar-thumb { background: #555; }
        ::-webkit-scrollbar-thumb:hover { background: #888; }
        html.dark ::-webkit-scrollbar-thumb:hover { background: #777; }
        
        /* Dark mode toggle switch style */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #60a5fa;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #60a5fa;
        }
    </style>
    <script>
        // Apply dark mode immediately from localStorage to prevent FOUC (Flash of Unstyled Content)
        if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
</head>
<body class="bg-slate-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200 transition-colors duration-300">

    <div class="flex flex-col md:flex-row h-screen">

        <!-- Sidebar for History -->
        <aside class="w-full md:w-1/3 lg:w-1/4 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 flex flex-col">
            <div class="p-4 border-b dark:border-gray-700 flex justify-between items-center">
                <h2 class="text-xl font-bold">変換履歴</h2>
                <div class="flex items-center space-x-2">
                     <button id="export-history-btn" title="履歴をエクスポート" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                    </button>
                    <button id="import-history-btn" title="履歴をインポート" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    </button>
                    <input type="file" id="import-file-input" class="hidden" accept=".json">
                </div>
            </div>
            <div class="p-4 border-b dark:border-gray-700">
                <input type="text" id="search-history" placeholder="履歴を検索..." class="w-full p-2 border rounded-lg bg-gray-50 dark:bg-gray-700 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition">
            </div>
            <div id="history-list" class="flex-grow overflow-y-auto p-2">
                <!-- History items will be injected here by JavaScript -->
                <p class="text-center text-gray-500 mt-4">履歴はありません。</p>
            </div>
        </aside>

        <!-- Main Content Area -->
        <main class="w-full md:w-2/3 lg:w-3/4 p-6 flex flex-col">
             <header class="mb-6 flex justify-between items-start">
                <div>
                    <h1 class="text-4xl font-bold text-gray-900 dark:text-white">AI音声文字起こし</h1>
                    <p class="text-gray-600 dark:text-gray-400 mt-2">Gemini 1.5 Proによる高精度な音声テキスト変換（話者分離対応）</p>
                </div>
                 <!-- Dark Mode Toggle -->
                <div class="flex items-center space-x-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="toggle" id="dark-mode-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="dark-mode-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>
                </div>
            </header>
            
            <!-- File Upload Section -->
            <div class="mb-6 p-6 bg-white dark:bg-gray-800 rounded-xl shadow-md border border-gray-200 dark:border-gray-700">
                <label for="audio-file" class="block text-lg font-semibold mb-2 text-gray-700 dark:text-gray-300">1. 音声ファイルを選択</label>
                <div class="flex items-center space-x-4">
                    <input type="file" id="audio-file" accept=".m4a" class="block w-full text-sm file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 dark:file:bg-blue-900 file:text-blue-700 dark:file:text-blue-300 hover:file:bg-blue-100 dark:hover:file:bg-blue-800 transition">
                    <button id="transcribe-btn" class="px-6 py-2 bg-blue-600 text-white font-bold rounded-full hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors disabled:bg-gray-400 dark:disabled:bg-gray-600 whitespace-nowrap">変換開始</button>
                </div>
                 <p id="file-name" class="mt-2 text-sm text-gray-500 dark:text-gray-400"></p>
            </div>

            <!-- Results Display Area -->
            <div id="result-section" class="flex-grow flex flex-col bg-white dark:bg-gray-800 rounded-xl shadow-md border border-gray-200 dark:border-gray-700 hidden p-6">
                <div class="flex justify-between items-center mb-4 flex-wrap gap-4">
                    <h2 class="text-2xl font-bold">変換結果</h2>
                    <div class="flex items-center space-x-2">
                        <select id="font-selector" class="p-2 border rounded-lg text-sm bg-gray-50 dark:bg-gray-700 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition"></select>
                         <button id="copy-btn" title="クリップボードにコピー" class="p-2 rounded-lg bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 transition">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                         </button>
                        <button id="save-txt-btn" class="px-4 py-2 bg-green-500 text-white font-semibold rounded-lg hover:bg-green-600 transition-colors text-sm">TXT</button>
                        <button id="save-docx-btn" class="px-4 py-2 bg-blue-500 text-white font-semibold rounded-lg hover:bg-blue-600 transition-colors text-sm">Word</button>
                    </div>
                </div>
                <div id="loading-spinner" class="flex flex-col items-center justify-center h-full hidden">
                    <div class="loader"></div>
                    <p class="mt-4 text-gray-600 dark:text-gray-400">AIが変換中です... (完了時に通知します)</p>
                </div>
                <textarea id="transcribed-text" class="w-full flex-grow p-4 border rounded-lg bg-gray-50 dark:bg-gray-900 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 text-base leading-relaxed resize-none"></textarea>
                
                <!-- Speaker Name Replacement Section -->
                <div id="speaker-replace-section" class="mt-4 p-4 border-t dark:border-gray-700">
                    <h3 class="font-semibold mb-2">話者名の置換</h3>
                    <div class="flex items-center space-x-2">
                        <input type="text" id="original-speaker" placeholder="元の名前 (例: 話者A)" class="w-full p-2 text-sm border rounded-lg bg-gray-50 dark:bg-gray-700 dark:border-gray-600">
                        <span class="text-gray-500">→</span>
                        <input type="text" id="new-speaker" placeholder="新しい名前 (例: 田中)" class="w-full p-2 text-sm border rounded-lg bg-gray-50 dark:bg-gray-700 dark:border-gray-600">
                        <button id="replace-speaker-btn" class="px-4 py-2 bg-gray-500 text-white font-semibold rounded-lg hover:bg-gray-600 transition-colors text-sm whitespace-nowrap">置換</button>
                    </div>
                </div>

                 <div class="mt-4 flex justify-end">
                    <button id="save-to-history-btn" class="px-6 py-2 bg-indigo-600 text-white font-bold rounded-full hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-colors">履歴に保存</button>
                </div>
            </div>
             <p id="error-message" class="text-red-500 mt-4 text-center font-semibold"></p>
        </main>
    </div>
    
    <!-- Modal for Editing Title -->
    <div id="edit-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 dark:bg-opacity-70 overflow-y-auto h-full w-full hidden z-50">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div class="mt-3 text-center">
                <h3 class="text-lg leading-6 font-medium text-gray-900 dark:text-white">ファイル名を編集</h3>
                <div class="mt-2 px-7 py-3">
                    <input type="text" id="edit-title-input" class="w-full p-2 border rounded-lg bg-gray-50 dark:bg-gray-700 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="items-center px-4 py-3">
                    <button id="save-title-btn" class="px-4 py-2 bg-blue-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-300">保存</button>
                     <button id="cancel-edit-btn" class="mt-2 px-4 py-2 bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-200 text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-300 dark:hover:bg-gray-500 focus:outline-none">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- All JavaScript logic is contained within this script tag -->
    <script>
        // Self-executing anonymous function to encapsulate code
        (() => {
            // DOM Elements
            const elements = {
                audioFileInput: document.getElementById('audio-file'),
                transcribeBtn: document.getElementById('transcribe-btn'),
                fileNameDisplay: document.getElementById('file-name'),
                resultSection: document.getElementById('result-section'),
                loadingSpinner: document.getElementById('loading-spinner'),
                transcribedText: document.getElementById('transcribed-text'),
                fontSelector: document.getElementById('font-selector'),
                copyBtn: document.getElementById('copy-btn'),
                saveTxtBtn: document.getElementById('save-txt-btn'),
                saveDocxBtn: document.getElementById('save-docx-btn'),
                saveToHistoryBtn: document.getElementById('save-to-history-btn'),
                historyList: document.getElementById('history-list'),
                searchHistoryInput: document.getElementById('search-history'),
                errorMessage: document.getElementById('error-message'),
                editModal: document.getElementById('edit-modal'),
                editTitleInput: document.getElementById('edit-title-input'),
                saveTitleBtn: document.getElementById('save-title-btn'),
                cancelEditBtn: document.getElementById('cancel-edit-btn'),
                darkModeToggle: document.getElementById('dark-mode-toggle'),
                originalSpeaker: document.getElementById('original-speaker'),
                newSpeaker: document.getElementById('new-speaker'),
                replaceSpeakerBtn: document.getElementById('replace-speaker-btn'),
                exportHistoryBtn: document.getElementById('export-history-btn'),
                importHistoryBtn: document.getElementById('import-history-btn'),
                importFileInput: document.getElementById('import-file-input'),
            };

            let selectedFile = null;
            let currentHistoryId = null;
            let db;

            const fonts = [
                { value: 'font-inter', text: '標準 (Inter)' },
                { value: 'font-noto', text: 'ゴシック (Noto Sans JP)' },
                { value: 'font-mincho', text: '明朝 (Kaisei Tokumin)' },
                { value: 'font-mono', text: '等幅 (Roboto Mono)' }
            ];

            function populateFontSelector() {
                fonts.forEach(font => {
                    const option = document.createElement('option');
                    option.value = font.value;
                    option.textContent = font.text;
                    elements.fontSelector.appendChild(option);
                });
            }

            // --- Database Initialization ---
            function initDB() {
                const request = indexedDB.open('VoiceToTextDB_v2', 1);
                request.onerror = e => showError('データベースの初期化に失敗しました。');
                request.onupgradeneeded = e => {
                    db = e.target.result;
                    const store = db.createObjectStore('history', { keyPath: 'id', autoIncrement: true });
                    store.createIndex('title', 'title', { unique: false });
                };
                request.onsuccess = e => {
                    db = e.target.result;
                    loadHistory();
                };
            }

            // --- Event Listeners ---
            function setupEventListeners() {
                elements.audioFileInput.addEventListener('change', handleFileSelect);
                elements.transcribeBtn.addEventListener('click', handleTranscription);
                elements.fontSelector.addEventListener('change', handleFontChange);
                elements.saveToHistoryBtn.addEventListener('click', saveToHistory);
                elements.historyList.addEventListener('click', handleHistoryAction);
                elements.searchHistoryInput.addEventListener('input', e => loadHistory(e.target.value));
                elements.saveTxtBtn.addEventListener('click', () => saveAsFile('txt'));
                elements.saveDocxBtn.addEventListener('click', () => saveAsFile('docx'));
                elements.saveTitleBtn.addEventListener('click', saveEditedTitle);
                elements.cancelEditBtn.addEventListener('click', () => toggleModal(false));
                elements.darkModeToggle.addEventListener('change', toggleDarkMode);
                elements.copyBtn.addEventListener('click', copyToClipboard);
                elements.replaceSpeakerBtn.addEventListener('click', replaceSpeakerName);
                elements.exportHistoryBtn.addEventListener('click', exportHistory);
                elements.importHistoryBtn.addEventListener('click', () => elements.importFileInput.click());
                elements.importFileInput.addEventListener('change', importHistory);
            }

            // --- UI Handlers ---
            function handleFileSelect(e) {
                selectedFile = e.target.files[0];
                elements.fileNameDisplay.textContent = selectedFile ? `選択中: ${selectedFile.name}` : '';
                elements.transcribeBtn.disabled = !selectedFile;
            }

            function handleFontChange() {
                elements.transcribedText.className = elements.transcribedText.className.replace(/\bfont-\S+/g, '');
                elements.transcribedText.classList.add(elements.fontSelector.value);
            }

            function toggleModal(show, id = null, title = '') {
                if (show) {
                    elements.editTitleInput.value = title;
                    elements.saveTitleBtn.dataset.id = id;
                    elements.editModal.classList.remove('hidden');
                } else {
                    elements.editModal.classList.add('hidden');
                }
            }
            
            function setDarkMode(isDark) {
                elements.darkModeToggle.checked = isDark;
                if (isDark) {
                    document.documentElement.classList.add('dark');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.documentElement.classList.remove('dark');
                    localStorage.setItem('theme', 'light');
                }
            }

            function toggleDarkMode() {
                setDarkMode(elements.darkModeToggle.checked);
            }

            function showError(message) {
                elements.errorMessage.textContent = message;
            }

            // --- Notification Logic (NEW) ---
            async function requestNotificationPermission() {
                if (!('Notification' in window)) {
                    console.log("This browser does not support desktop notification");
                    return;
                }
                if (Notification.permission === 'default') {
                    await Notification.requestPermission();
                }
            }
            
            function showNotification(title, body) {
                if (Notification.permission === 'granted') {
                    new Notification(title, { body });
                }
            }

            // --- Core Logic ---
            async function handleTranscription() {
                if (!selectedFile) return showError('ファイルが選択されていません。');
                
                // Request notification permission on user action
                await requestNotificationPermission();

                showError('');
                elements.resultSection.classList.remove('hidden');
                elements.loadingSpinner.classList.remove('hidden');
                elements.transcribedText.value = '';
                
                try {
                    const base64Audio = await fileToBase64(selectedFile);
                    const mimeType = selectedFile.type || 'audio/m4a';
                    const text = await callGeminiApi(base64Audio, mimeType);
                    elements.transcribedText.value = text;
                    currentHistoryId = null;
                    // Show success notification
                    showNotification('文字起こし完了', `${selectedFile.name} の変換が完了しました。`);
                } catch (error) {
                    console.error('Transcription error:', error);
                    showError(`変換エラー: ${error.message}`);
                    // Show error notification
                    showNotification('変換エラー', `エラーが発生しました: ${error.message}`);
                } finally {
                    elements.loadingSpinner.classList.add('hidden');
                }
            }

            async function callGeminiApi(base64Data, mimeType, retries = 3, delay = 1000) {
                const apiKey = ""; // Canvas will provide it
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const systemPrompt = `あなたはプロの文字起こし担当者です。提供された音声データを、話している人物を区別して正確に日本語で文字起こししてください。話者の名前は「話者A」「話者B」のように明確に区別して表記してください。不要な相槌やフィラー（「えーと」「あのー」など）は適切に削除または整形し、読みやすいテキストを作成してください。`;
                const payload = {
                    contents: [{ parts: [{ text: systemPrompt }, { inlineData: { mimeType, data: base64Data } }] }],
                };

                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        const errorBody = await response.json();
                        throw new Error(`API Error ${response.status}: ${errorBody.error?.message || response.statusText}`);
                    }
                    const result = await response.json();
                    const candidate = result.candidates?.[0];
                    if (candidate?.content?.parts?.[0]?.text) {
                        return candidate.content.parts[0].text;
                    }
                    throw new Error('予期しないAPIレスポンス形式です。');
                } catch(error) {
                    if (retries > 0) {
                        await new Promise(res => setTimeout(res, delay));
                        return callGeminiApi(base64Data, mimeType, retries - 1, delay * 2);
                    }
                    throw error;
                }
            }

            // --- History Management ---
            function saveToHistory() {
                const text = elements.transcribedText.value;
                if (!text || !db) return;
                const transaction = db.transaction(['history'], 'readwrite');
                const store = transaction.objectStore('history');
                const title = selectedFile?.name || `無題 - ${new Date().toLocaleString()}`;
                const data = { title, text, font: elements.fontSelector.value, timestamp: new Date() };
                if (currentHistoryId) data.id = currentHistoryId;

                const request = currentHistoryId ? store.put(data) : store.add(data);
                request.onsuccess = e => {
                    if (!currentHistoryId) currentHistoryId = e.target.result;
                    loadHistory();
                    alert('履歴に保存しました。');
                };
                request.onerror = () => showError('履歴の保存に失敗しました。');
            }

            function loadHistory(searchTerm = '') {
                if (!db) return;
                const store = db.transaction(['history'], 'readonly').objectStore('history');
                store.getAll().onsuccess = e => {
                    elements.historyList.innerHTML = '';
                    let allHistory = e.target.result.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    if (searchTerm) {
                        allHistory = allHistory.filter(item => item.title.toLowerCase().includes(searchTerm.toLowerCase()));
                    }
                    if (allHistory.length === 0) {
                        elements.historyList.innerHTML = `<p class="text-center text-gray-500 mt-4">${searchTerm ? '検索結果なし' : '履歴なし'}</p>`;
                        return;
                    }
                    allHistory.forEach(renderHistoryItem);
                };
            }

            function renderHistoryItem(item) {
                const div = document.createElement('div');
                div.className = 'p-3 mb-2 bg-gray-100 dark:bg-gray-700 rounded-lg cursor-pointer hover:bg-blue-100 dark:hover:bg-blue-900 relative group transition';
                div.dataset.id = item.id;
                div.innerHTML = `
                    <p class="font-semibold text-gray-800 dark:text-gray-200 truncate">${item.title}</p>
                    <p class="text-xs text-gray-500 dark:text-gray-400">${new Date(item.timestamp).toLocaleString()}</p>
                    <div class="absolute top-2 right-2 flex space-x-1 opacity-0 group-hover:opacity-100 transition-opacity">
                        <button data-action="edit" title="編集" class="p-1 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.5L14.732 3.732z"></path></svg></button>
                        <button data-action="delete" title="削除" class="p-1 rounded-full hover:bg-gray-300 dark:hover:bg-gray-600"><svg class="w-4 h-4 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    </div>`;
                elements.historyList.appendChild(div);
            }
            
            function handleHistoryAction(e) {
                const target = e.target.closest('button, div[data-id]');
                if (!target) return;
                const id = parseInt(target.closest('div[data-id]').dataset.id, 10);
                const action = target.dataset.action;
                const store = db.transaction(['history'], 'readwrite').objectStore('history');

                if (action === 'edit') {
                    store.get(id).onsuccess = e => toggleModal(true, id, e.target.result.title);
                } else if (action === 'delete' && confirm('この履歴を削除しますか？')) {
                    store.delete(id).onsuccess = () => loadHistory();
                } else if (!action) {
                    store.get(id).onsuccess = e => {
                        const item = e.target.result;
                        elements.resultSection.classList.remove('hidden');
                        elements.transcribedText.value = item.text;
                        elements.fontSelector.value = item.font || fonts[0].value;
                        handleFontChange();
                        currentHistoryId = item.id;
                        selectedFile = null;
                        elements.fileNameDisplay.textContent = `履歴から読み込み: ${item.title}`;
                    };
                }
            }
            
            function saveEditedTitle() {
                const id = parseInt(elements.saveTitleBtn.dataset.id, 10);
                const newTitle = elements.editTitleInput.value.trim();
                if (!newTitle) return;

                const store = db.transaction(['history'], 'readwrite').objectStore('history');
                store.get(id).onsuccess = e => {
                    const item = e.target.result;
                    item.title = newTitle;
                    store.put(item).onsuccess = () => {
                        toggleModal(false);
                        loadHistory();
                        if (currentHistoryId === id) {
                            elements.fileNameDisplay.textContent = `履歴から読み込み: ${newTitle}`;
                        }
                    };
                };
            }

            function exportHistory() {
                if (!db) return;
                db.transaction('history').objectStore('history').getAll().onsuccess = e => {
                    const data = JSON.stringify(e.target.result, null, 2);
                    const blob = new Blob([data], { type: 'application/json' });
                    triggerDownload(blob, `transcription-history-${new Date().toISOString().split('T')[0]}.json`);
                };
            }

            function importHistory(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = re => {
                    try {
                        const data = JSON.parse(re.target.result);
                        if (!Array.isArray(data)) throw new Error('Invalid format');
                        if (!confirm('現在の履歴を消去してインポートしますか？')) return;
                        
                        const transaction = db.transaction('history', 'readwrite');
                        const store = transaction.objectStore('history');
                        store.clear().onsuccess = () => {
                            data.forEach(item => store.add(item));
                        };
                        transaction.oncomplete = () => loadHistory();

                    } catch (err) {
                        showError('無効なファイル形式です。');
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; // Reset file input
            }
            
            // --- Feature Functions ---
            function copyToClipboard() {
                navigator.clipboard.writeText(elements.transcribedText.value).then(() => {
                    const originalText = elements.copyBtn.innerHTML;
                    elements.copyBtn.innerHTML = 'コピーしました!';
                    setTimeout(() => { elements.copyBtn.innerHTML = originalText; }, 2000);
                }).catch(() => showError('コピーに失敗しました。'));
            }

            function replaceSpeakerName() {
                const original = elements.originalSpeaker.value.trim();
                const replacement = elements.newSpeaker.value.trim();
                if (!original || !replacement) return;
                elements.transcribedText.value = elements.transcribedText.value.replaceAll(original, replacement);
                elements.originalSpeaker.value = '';
                elements.newSpeaker.value = '';
            }

            // --- Utility Functions ---
            function fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                });
            }

            function saveAsFile(type) {
                const text = elements.transcribedText.value;
                const title = getDownloadTitle();
                if (type === 'txt') {
                    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                    triggerDownload(blob, `${title}.txt`);
                } else if (type === 'docx') {
                    const paragraphs = text.split('\n').map(p => new docx.Paragraph({ children: [new docx.TextRun(p)] }));
                    const doc = new docx.Document({ sections: [{ children: paragraphs }] });
                    docx.Packer.toBlob(doc).then(blob => triggerDownload(blob, `${title}.docx`));
                }
            }

            function getDownloadTitle() {
                if (currentHistoryId) {
                    const titleElem = document.querySelector(`div[data-id='${currentHistoryId}'] p:first-child`);
                    return titleElem ? titleElem.textContent.replace(/\.m4a$/i, '') : 'transcription';
                }
                return selectedFile ? selectedFile.name.replace(/\.m4a$/i, '') : 'transcription';
            }

            function triggerDownload(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // --- Initializer ---
            function init() {
                populateFontSelector();
                initDB();
                setupEventListeners();
                setDarkMode(localStorage.getItem('theme') === 'dark');
            }

            // Run initialization on DOM content loaded
            document.addEventListener('DOMContentLoaded', init);
        })();
    </script>
</body>
</html>
